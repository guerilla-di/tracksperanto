== Extending Tracksperanto

=== Importing your own formats

You can easily write a Tracksperanto import module - refer to Tracksperanto::Import::Base
docs. Your importer will be configured with width and height of the comp that it is importing, and will get an IO 
object with the file that you are processing. The parse method should then return an array of Tracksperanto::Tracker objects which
are themselves arrays of Tracksperanto::Keyframe objects.

=== Exporting your own formats

You can easily write an exporter. Refer to the Tracksperanto::Export::Base docs. Note that your exporter should be able to chew alot of data
(hundreds of trackers with thousands of keyframes with exported files growing up to 5-10 megs in size are not uncommon!). This means that
the exporter should work with streams (smaller parts of the file being exported will be held in memory at a time).

=== Ading your own processing steps

You probably want to write a Middleware (consult the Tracksperanto::Middleware::Base docs) if you need some processing applied to the tracks
or their data. A Middleware is just like an export module, except that instead it sits between the exporter and the exporting routine. Middlewares wrap export
modules or each other, so you can stack different middleware modules together (like "scale first, then move").

=== Writing your own processing routines

You probably want to write a descendant of Tracksperanto::Pipeline::Base. This is a class that manages a conversion from start to finish, including detecting the
input format, allocating output files and building a chain of Middlewares to process the export. If you want to make a GUI for Tracksperanto you will likely need
to write your own Pipeline class or reimplement parts of it.

=== Reporting status from long-running operations

Almost every module in Tracksperanto has a method called report_progress. This method is used to notify an external callback of what you are doing, and helps keep
the software user-friendly. A well-behaved Tracksperanto module should manage it's progress reports properly.

=== Sample script

require "rubygems"
require "tracksperanto"

include Tracksperanto

# Create the importer object
some_importer = Importer.new(:width => 1024, :height => 576)

# Some object responding to #push has to be the receiver
# In this case we will use an array but this might get out of hand
# if you have alot of trackers - Tracksperanto uses a disk-based
# buffer for this instead (see Accumulator)
some_importer.receiver = [] 

# Run the import with the importer
some_importer.stream_parse((File.open("source_file.fmt")))

# Now the receiver contains trackers! Weeee!
trackers = importer.receiver

# Create the exporter and pass the output file to it
some_exporter = Exporter.new(File.open("exported_file.other", "wb"))

# Now add some middlewares, for example a Scale
scaler = Middleware::Scaler.new(some_exporter, :x_factor => 2)
# ... and a slip
slipper = Middleware::Slipper.new(scaler, :offset => 2)
# Middlewares wrap exporters and other middlewares, so you can chain them
# ad nauseam

# Now when we send export commands to the Slipper it will play them through
# to the Scaler and the Scaler in turn will send commands to the exporter.
slipper.start_export(1024, 576)
trackers.each do | t |
 slipper.start_tracker_segment(t.name)
 t.each {|kf slipper.export_point(kf.frame, kf.abs_x, kf.abs_y, kf.residual) }
 slipper.end_tracker_segment
end

# And we are done!