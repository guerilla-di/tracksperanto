#!/usr/bin/env ruby
# == Synopsis
# 
# Translate a 2D track file from a single format to many others
#
# == Usage
# 
#   tracksperanto -w 1920 -h 1080 /Films/Blockbuster/Shots/001/script.shk --only flamestabilizer
#   
# == Author
#   Julik <me@julik.nl>

require File.dirname(__FILE__) + '/../lib/tracksperanto' unless defined?(Tracksperanto)
require 'optparse'
require 'rubygems'
require 'progressbar'
require "update_hints"

def disclaimer
  "Please consider a small donation to keep Tracksperanto going. http://guerilla-di.org/source-and-license/\n"+
  "For information and support please contact info#{64.chr}guerilla-di.org"
end

options = {}
$middlewares = []
writer_class_name = nil
readers = Tracksperanto.importer_names
writers = Tracksperanto.exporter_names

op = OptionParser.new

def mw(name, option, default_value = nil)
  Proc.new do |value| 
    v = value.nil? ? default_value : value
    $middlewares.push([name, {option => v}])
  end
end

def list_exporters(dest = $stderr)
  dest.puts "The following export modules are available:"
  Tracksperanto.exporters.each do | exporter |
    dest.puts "\t#{exporter.const_name.downcase.inspect} - #{exporter.human_name}"
  end
end

def list_importers(dest = $stderr)
  dest.puts "The following import modules are available:"
  Tracksperanto.importers.each do | importer |
    dest.puts "\t#{importer.const_name.downcase.inspect} - #{importer.human_name}"
  end
end

class CodeLoaded < RuntimeError; end

op.banner = "Usage: tracksperanto -f ShakeScript -w 1920 -h 1080 /Films/Blockbuster/Shots/001/script.shk"
op.on("--code PATH_TO_SCRIPT", String, "Load custom Ruby code into tracksperanto") do |c|  
  unless $code
    require(c)
    raise CodeLoaded
  end
end


op.on(" -f", "--from TRANSLATOR", String, "Use the specific import translator") { |f| options[:importer] = f }
op.on(" -w", "--width WIDTH_IN_PIXELS", Integer, "Absolute input comp width in pixels (will try to autodetect)") { |w| options[:width] = w }
op.on(" -h", "--height HEIGHT_IN_PIXELS", Integer, "Absolute input comp height in pixels (will try to autodetect)") {|w| options[:height] = w }
op.on(" -o", "--only EXPORTER_NAME", String, "Only export the selected format, format must be one of #{writers.join(", ")}") { |f| writer_class_name = f }

op.on(" -xs", "--xscale X_SCALING_FACTOR", Float, "Scale the result in X by this factor (1.0 is the default)", &mw("Scaler", :x_factor))
op.on(" -ys", "--yscale Y_SCALING_FACTOR", Float, "Scale the result in Y by this factor (1.0 is the default)", &mw("Scaler", :y_factor))
op.on(" -t", "--trim", "Trim the start frames (do not allow negative frame values)",  &mw("StartTrim", :enabled, true)) # Before slip!
op.on(" -s", "--slip FRAMES", Integer, "Slip the result by this number of frames, positive is 'later'", &mw("Slipper", :slip))

op.on(" -g", "--golden", "Reset the residuals of all trackers to 0 (ignore correlation)", &mw("Golden", :enabled, true))
op.on(" -rx", "--reformat-x NEW_PIX_WIDTH", Integer, "Reformat the comp to this width and scale all tracks to it", &mw("Reformat", :width))
op.on(" -ry", "--reformat-y NEW_PIX_HEIGHT", Integer, "Reformat the comp to this height and scale all tracks to it", &mw("Reformat", :height))
op.on(" -m", "--min-length LENGTH_IN_FRAMES", Integer, "Only export trackers having more than X keyframes", &mw("LengthCutoff", :min_length))
op.on(" -xm", "--xshift X_IN_PIXELS", Float, "Move the points left or right", &mw("Shift", :x_shift))
op.on(" -ym", "--yshift Y_IN_PIXELS", Float, "Move the points up or down", &mw("Shift", :y_shift)) 
op.on(" -p", "--prefix PREFIX", String, "A prefix to prepend to tracker names in bulk", &mw("Prefix", :prefix))
op.on("--lerp", "Linearly interpolate missing keyframes", &mw("Lerp", :enabled, true))
op.on("--flip", "Flip the comp horizontally", &mw("Flip", :enabled, true))
op.on("--flop", "Flop the comp vertically", &mw("Flop", :enabled, true))
op.on("--list-exporters", "Show available export modules") do
  list_exporters; exit(0)
end
op.on("--list-importers", "Show available import modules") do
  list_importers; exit(0)
end
op.on("--version", "Show the version and exit") do |v| 
    puts "Tracksperanto v.#{Tracksperanto::VERSION} running on Ruby #{RUBY_VERSION} on #{RUBY_PLATFORM}"
    puts "Copyright 2008-#{Time.now.year} by Guerilla-DI (Julik Tarkhanov and contributors)"
    puts disclaimer
    UpdateHints.version_check("tracksperanto", Tracksperanto::VERSION, STDOUT)
    exit(0)
end

begin
  op.parse!
rescue CodeLoaded
  $code = true
  retry
end

input_file = ARGV.pop
unless input_file
  $stderr.puts "No input file provided - should be the last argument. Also use the --help option."
  exit(1)
end

unless File.exist?(input_file)
  $stderr.puts "Input file #{input_file} does not exist"
  exit(1)
end

pbar = ProgressBar.new("Converting", 100, $stdout)
progress = lambda{|percent,message| pbar.set(percent) }
begin
  pipe = Tracksperanto::Pipeline::Base.new(:progress_block => progress, :middleware_tuples => $middlewares)
  pipe.exporters = [Tracksperanto.get_exporter(writer_class_name)] if writer_class_name
  pipe.run(input_file, options)
rescue Tracksperanto::UnknownExporterError => damn
  $stderr.puts damn.message
  list_exporters($stderr)
  exit(2)
rescue Tracksperanto::UnknownImporterError => damn
  $stderr.puts damn.message
  list_importers($stderr)
  exit(2)
rescue Tracksperanto::UnknownMiddlewareError => damn
  $stderr.puts damn.message
  $stderr.puts "This is a bug, please report it"
  exit(2)
ensure
  pbar.finish
end

puts disclaimer
UpdateHints.version_check("tracksperanto", Tracksperanto::VERSION, STDOUT)